#!/usr/bin/env ruby
# encoding: UTF-8

def format_commit_info timestamp, time_desc, author, commit_id, message, ref_name
  [
    "#{timestamp.strftime("%d %m %Y")} #{timestamp.strftime("%l:%M%p").downcase}",
    time_desc,
    author,
    commit_id,
    message,
    ref_name
  ]
end

def render_commit_info timestamp, time_desc, author, commit_id, message, ref_name, merged
  trunc_limit = 33
  branch_chracter_count = ref_name[0..trunc_limit].strip.length
  [
    "\e[90m#{time_desc}\e[0m",
    "\e[37m#{author}\e[0m",
    (merged ? "\e[32m✓\e[m #{commit_id}" : "\e[31m✗\e[m \e[33m#{commit_id}\e[0m"),
    # "\e[32m#{branch_chracter_count > trunc_limit ? ref_name[0..trunc_limit].gsub(/$/, '…') : ref_name[0..trunc_limit+1]}\e[0m",
    "\e[32m#{ref_name.strip}\e[0m ",
    "\e[#{message[/^Temp/] ? 31 : 90}m#{message.strip}\e[0m",
  ].join(' ')
end
  

commit_info = `git branch #{ARGV.join(' ')} | cut -c 3-`.strip.split("\n").reject {|ref_name|
  ref_name[' -> ']
}.map {|ref_name|
  `git log --no-walk --pretty=format:"%ct\n%cr\n%an\n%h\n%s" '#{ref_name}' --`.strip.split("\n").push(ref_name)
}.map {|commit_info|
  [Time.at(commit_info.shift.to_i)].concat(commit_info)
}.sort_by {|commit_info|
  commit_info.first # unix timestamp
}.map {|commit_info|  # <- `.reverse.map` for newset at top
  format_commit_info(*commit_info)
}.transpose.map {|column|
  max_col_length = column.sort_by {|i| i.length }.last.length
  column.map {|i| i.ljust(max_col_length) }
}.transpose.map {|commit_info|
  commit_info.push(
   `git merge-base HEAD #{commit_info[3]}`.chomp[0...8] == commit_info[3]
  )
}.each {|commit_info|
  puts render_commit_info(*commit_info)
}