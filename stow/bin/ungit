#!/usr/bin/env bash

# Download a repository, directory, or file from GitHub
# Supports shorthand, HTTPS URLs, and SSH formats

set -euo pipefail

# Maximum file size for prompt output (100KB)
MAX_FILE_SIZE=102400

# Filter patterns (populated by -i/-e flags)
INCLUDE_PATTERNS=()
EXCLUDE_PATTERNS=()

print_usage() {
  cat <<EOF
Usage: ungit [options] <source[@branch]> [destination]

Download a repository, directory, or file from GitHub.

Options:
  -p, --prompt        Output files as XML-formatted text for LLM prompts
                      instead of downloading to disk
  -i, --include GLOB  Only include files matching pattern (can be repeated)
  -e, --exclude GLOB  Exclude files matching pattern (can be repeated)

Formats:
  Shorthand:
    ungit user/repo                      # Download entire repo to ./repo
    ungit user/repo@branch               # From specific branch
    ungit user/repo/path                 # Download specific path
    ungit user/repo/path@branch          # Path from specific branch

  HTTPS URL:
    ungit https://github.com/user/repo                    # Whole repo
    ungit https://github.com/user/repo.git                # With .git suffix
    ungit https://github.com/user/repo.git@branch         # Specific branch

  SSH:
    ungit git@github.com:user/repo                        # Whole repo
    ungit git@github.com:user/repo.git@branch             # Specific branch

  GitHub tree URL (for directories/files):
    ungit https://github.com/user/repo/tree/branch/path
    ungit https://github.com/user/repo/tree/main/src
    ungit https://github.com/user/repo/tree/abc123/path   # Permalink

Examples:
  ungit tyom/dotfiles                    # Download entire repo
  ungit tyom/dotfiles@master             # From 'master' branch
  ungit tyom/dotfiles/zsh                # Download specific directory
  ungit tyom/dotfiles/zsh@master         # Directory from specific branch
  ungit tyom/dotfiles ./my-dotfiles      # Custom destination
  ungit git@github.com:tyom/dotfiles.git # SSH format
  ungit https://github.com/tyom/dotfiles/tree/master/zsh
EOF
}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
NC='\033[0m'

error() {
  echo -e "${RED}Error:${NC} $1" >&2
  exit 1
}

info() {
  echo -e "${GREEN}$1${NC}"
}

# Check if file is binary
is_binary_file() {
  local file="$1"
  local mime
  mime=$(file --mime-type -b "$file")
  [[ ! "$mime" =~ ^text/ ]]
}

# Check if file matches include/exclude filters
matches_filter() {
  local rel_path="$1"
  local basename
  basename=$(basename "$rel_path")

  # If include patterns exist, file must match at least one
  if [[ ${#INCLUDE_PATTERNS[@]} -gt 0 ]]; then
    local matched=false
    for pattern in "${INCLUDE_PATTERNS[@]}"; do
      # shellcheck disable=SC2053
      if [[ "$rel_path" == $pattern ]] || [[ "$basename" == $pattern ]]; then
        matched=true
        break
      fi
    done
    [[ "$matched" == false ]] && return 1
  fi

  # Check exclude patterns - if any match, exclude the file
  for pattern in "${EXCLUDE_PATTERNS[@]}"; do
    # shellcheck disable=SC2053
    if [[ "$rel_path" == $pattern ]] || [[ "$basename" == $pattern ]]; then
      return 1
    fi
  done

  return 0
}

# Generate directory tree structure
generate_tree() {
  local base_dir="$1"
  local prefix="${2:-}"
  local root_path="${3:-$base_dir}"

  while IFS= read -r entry; do
    local name
    name=$(basename "$entry")
    local rel_path="${entry#$root_path/}"

    if [[ -d "$entry" ]]; then
      # For directories, check if any files inside would match
      local has_matching_files=false
      if [[ ${#INCLUDE_PATTERNS[@]} -eq 0 && ${#EXCLUDE_PATTERNS[@]} -eq 0 ]]; then
        has_matching_files=true
      else
        while IFS= read -r subfile; do
          local sub_rel="${subfile#$root_path/}"
          if matches_filter "$sub_rel"; then
            has_matching_files=true
            break
          fi
        done < <(find "$entry" -type f 2>/dev/null)
      fi

      if [[ "$has_matching_files" == true ]]; then
        echo "${prefix}${name}/"
        generate_tree "$entry" "  ${prefix}" "$root_path"
      fi
    else
      if matches_filter "$rel_path"; then
        echo "${prefix}${name}"
      fi
    fi
  done < <(find "$base_dir" -mindepth 1 -maxdepth 1 | sort)
}

# Output files in prompt format
output_prompt_format() {
  local source_path="$1"
  local base_name="$2"

  echo "<directory_structure>"
  if [[ -d "$source_path" ]]; then
    echo "${base_name}/"
    generate_tree "$source_path" "  " "$source_path"
  else
    local file_basename
    file_basename=$(basename "$source_path")
    if matches_filter "$file_basename"; then
      echo "$base_name"
    fi
  fi
  echo "</directory_structure>"
  echo ""
  echo "<files>"

  if [[ -d "$source_path" ]]; then
    while IFS= read -r file; do
      local rel_path="${file#$source_path/}"
      local full_rel_path="${base_name}/${rel_path}"

      # Apply filter
      matches_filter "$rel_path" || continue

      local file_size
      file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)

      echo "<file path=\"${full_rel_path}\">"
      if [[ "$file_size" -gt "$MAX_FILE_SIZE" ]]; then
        echo "[file too large]"
      elif is_binary_file "$file"; then
        echo "[binary file]"
      else
        cat "$file"
      fi
      echo "</file>"
      echo ""
    done < <(find "$source_path" -type f | sort)
  else
    local file_basename
    file_basename=$(basename "$source_path")

    if matches_filter "$file_basename"; then
      local file_size
      file_size=$(stat -f%z "$source_path" 2>/dev/null || stat -c%s "$source_path" 2>/dev/null)

      echo "<file path=\"${base_name}\">"
      if [[ "$file_size" -gt "$MAX_FILE_SIZE" ]]; then
        echo "[file too large]"
      elif is_binary_file "$source_path"; then
        echo "[binary file]"
      else
        cat "$source_path"
      fi
      echo "</file>"
    fi
  fi

  echo "</files>"
}

# Check dependencies
check_deps() {
  local missing=()
  for cmd in curl tar; do
    if ! command -v "$cmd" &>/dev/null; then
      missing+=("$cmd")
    fi
  done
  if [[ ${#missing[@]} -gt 0 ]]; then
    error "Missing required commands: ${missing[*]}"
  fi
}

# Check if a ref (branch, tag, or commit) exists
check_ref_exists() {
  local user="$1"
  local repo="$2"
  local ref="$3"

  # Try branches API first
  local http_code
  http_code=$(curl -sL -o /dev/null -w "%{http_code}" \
    "https://api.github.com/repos/$user/$repo/branches/$ref")
  [[ "$http_code" == "200" ]] && return 0

  # Try commits API (for SHAs and tags)
  http_code=$(curl -sL -o /dev/null -w "%{http_code}" \
    "https://api.github.com/repos/$user/$repo/commits/$ref")
  [[ "$http_code" == "200" ]] && return 0

  return 1
}

# Resolve branch and path from ambiguous tree URL segment
# Branch names can contain slashes, so we need to probe the API
# e.g., "klazuka/add-feature/src/lib" could be:
#   - branch "klazuka", path "add-feature/src/lib"
#   - branch "klazuka/add-feature", path "src/lib"
#   - branch "klazuka/add-feature/src", path "lib"
#   - branch "klazuka/add-feature/src/lib", no path
resolve_branch_and_path() {
  local user="$1"
  local repo="$2"
  local ref_and_path="$3"

  # Split into segments
  IFS='/' read -ra segments <<<"$ref_and_path"
  local num_segments=${#segments[@]}

  # Try progressively longer ref names until we find one that exists
  local try_ref=""
  for ((i = 0; i < num_segments; i++)); do
    if [[ -z "$try_ref" ]]; then
      try_ref="${segments[i]}"
    else
      try_ref="$try_ref/${segments[i]}"
    fi

    if check_ref_exists "$user" "$repo" "$try_ref"; then
      BRANCH="$try_ref"
      # Remaining segments form the path
      if [[ $((i + 1)) -lt $num_segments ]]; then
        PATH_IN_REPO=$(
          IFS=/
          echo "${segments[*]:$((i + 1))}"
        )
      else
        PATH_IN_REPO=""
      fi
      return 0
    fi
  done

  # No ref found - use the whole thing (will fail later with clear error)
  BRANCH="$ref_and_path"
  PATH_IN_REPO=""
  return 0
}

# Parse input and set USER, REPO, BRANCH, PATH_IN_REPO
parse_input() {
  local input="$1"
  local branch=""

  USER=""
  REPO=""
  BRANCH="HEAD"
  PATH_IN_REPO=""

  # GitHub tree URL: https://github.com/user/repo/tree/ref-and-path
  # Branch names can contain slashes, so we need to resolve them via API
  if [[ "$input" =~ ^https?://github\.com/([^/]+)/([^/]+)/tree/(.+)$ ]]; then
    USER="${BASH_REMATCH[1]}"
    REPO="${BASH_REMATCH[2]%.git}"
    local ref_and_path="${BASH_REMATCH[3]}"
    resolve_branch_and_path "$USER" "$REPO" "$ref_and_path"
    return
  fi

  # Extract @branch suffix (before normalizing URL)
  if [[ "$input" =~ ^(.+)@([^@/]+)$ ]]; then
    branch="${BASH_REMATCH[2]}"
    input="${BASH_REMATCH[1]}"
  fi

  # HTTPS URL: https://github.com/user/repo[.git]
  if [[ "$input" =~ ^https?://github\.com/([^/]+)/([^/]+)/?$ ]]; then
    USER="${BASH_REMATCH[1]}"
    REPO="${BASH_REMATCH[2]%.git}"
    [[ -n "$branch" ]] && BRANCH="$branch" || true
    return
  fi

  # SSH format: git@github.com:user/repo[.git]
  if [[ "$input" =~ ^git@github\.com:([^/]+)/([^/]+)/?$ ]]; then
    USER="${BASH_REMATCH[1]}"
    REPO="${BASH_REMATCH[2]%.git}"
    [[ -n "$branch" ]] && BRANCH="$branch" || true
    return
  fi

  # Shorthand: user/repo
  if [[ "$input" =~ ^([^/]+)/([^/]+)$ ]]; then
    USER="${BASH_REMATCH[1]}"
    REPO="${BASH_REMATCH[2]%.git}"
    [[ -n "$branch" ]] && BRANCH="$branch" || true
    return
  fi

  # Shorthand with path: user/repo/path/to/dir
  if [[ "$input" =~ ^([^/]+)/([^/]+)/(.+)$ ]]; then
    USER="${BASH_REMATCH[1]}"
    REPO="${BASH_REMATCH[2]%.git}"
    PATH_IN_REPO="${BASH_REMATCH[3]}"
    [[ -n "$branch" ]] && BRANCH="$branch" || true
    return
  fi

  error "Invalid format: $input

Supported formats:
  user/repo[@branch]
  user/repo/path[@branch]
  https://github.com/user/repo[.git][@branch]
  git@github.com:user/repo[.git][@branch]
  https://github.com/user/repo/tree/branch/path"
}

main() {
  local prompt_mode=false

  # Parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -p|--prompt)
        prompt_mode=true
        shift
        ;;
      -i|--include)
        [[ -z "${2:-}" ]] && error "Option $1 requires a pattern argument"
        INCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      -e|--exclude)
        [[ -z "${2:-}" ]] && error "Option $1 requires a pattern argument"
        EXCLUDE_PATTERNS+=("$2")
        shift 2
        ;;
      -h|--help)
        print_usage
        exit 0
        ;;
      *)
        break
        ;;
    esac
  done

  if [[ $# -lt 1 ]]; then
    print_usage
    exit 0
  fi

  check_deps
  parse_input "$1"

  # Determine destination/base name
  local dest
  if [[ -n "${2:-}" ]]; then
    dest="$2"
  elif [[ -n "$PATH_IN_REPO" ]]; then
    dest=$(basename "$PATH_IN_REPO")
  else
    dest="$REPO"
  fi

  # Display what we're fetching (skip in prompt mode for clean output)
  local fetch_desc="$USER/$REPO"
  [[ -n "$PATH_IN_REPO" ]] && fetch_desc="$fetch_desc/$PATH_IN_REPO"
  [[ "$prompt_mode" != true ]] && info "Fetching $fetch_desc (ref: $BRANCH)..."

  # Create temp directory
  UNGIT_TMPDIR=$(mktemp -d)
  trap 'rm -rf "$UNGIT_TMPDIR"' EXIT INT TERM
  local tmpdir="$UNGIT_TMPDIR"

  # Download the tarball
  local tarball_url="https://api.github.com/repos/$USER/$REPO/tarball/$BRANCH"
  local tarball="$tmpdir/repo.tar.gz"

  if ! curl -sL -o "$tarball" -w "%{http_code}" "$tarball_url" | grep -q "^200$"; then
    local http_code
    http_code=$(curl -sL -o /dev/null -w "%{http_code}" "$tarball_url")
    if [[ "$http_code" == "404" ]]; then
      error "Repository or branch not found: $USER/$REPO (ref: $BRANCH)"
    else
      error "Failed to download from GitHub (HTTP $http_code)"
    fi
  fi

  # Extract tarball
  tar -xzf "$tarball" -C "$tmpdir"

  # Find the extracted directory (GitHub adds a prefix like user-repo-hash)
  local extracted_dir
  extracted_dir=$(find "$tmpdir" -maxdepth 1 -type d -name "$USER-$REPO-*" | head -1)

  if [[ -z "$extracted_dir" ]]; then
    error "Failed to extract repository archive"
  fi

  # Determine source path
  local source_path="$extracted_dir"
  if [[ -n "$PATH_IN_REPO" ]]; then
    source_path="$extracted_dir/$PATH_IN_REPO"
    if [[ ! -e "$source_path" ]]; then
      error "Path not found in repository: $PATH_IN_REPO"
    fi
  fi

  # Output in prompt format or copy to destination
  if [[ "$prompt_mode" == true ]]; then
    output_prompt_format "$source_path" "$dest"
  else
    if [[ -d "$source_path" ]]; then
      mkdir -p "$dest"
      # If filters are set, copy files selectively
      if [[ ${#INCLUDE_PATTERNS[@]} -gt 0 || ${#EXCLUDE_PATTERNS[@]} -gt 0 ]]; then
        local file_count=0
        while IFS= read -r file; do
          local rel_path="${file#$source_path/}"
          matches_filter "$rel_path" || continue

          local dest_file="$dest/$rel_path"
          mkdir -p "$(dirname "$dest_file")"
          cp "$file" "$dest_file"
          ((file_count++)) || true
        done < <(find "$source_path" -type f)
        info "Downloaded $file_count files to: $dest"
      else
        cp -R "$source_path/." "$dest/"
        info "Downloaded to: $dest"
      fi
    else
      local file_basename
      file_basename=$(basename "$source_path")
      if ! matches_filter "$file_basename"; then
        error "File excluded by filter: $file_basename"
      fi

      if [[ -d "$dest" ]]; then
        cp "$source_path" "$dest/"
        info "Downloaded file to: $dest/$(basename "$source_path")"
      else
        cp "$source_path" "$dest"
        info "Downloaded file to: $dest"
      fi
    fi
  fi
}

main "$@"
