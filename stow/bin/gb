#!/usr/bin/env bash

# Git branches with formatted output, sorted by commit date
# Usage: gb [git-branch-args...]

set -e

# Colors (using $'...' syntax for proper escape interpretation)
RESET=$'\033[0m'
BRIGHT=$'\033[1m'
GRAY=$'\033[90m'
LIGHT_GRAY=$'\033[38;5;246m'
GREEN=$'\033[32m'
YELLOW=$'\033[33m'
WHITE=$'\033[37m'

truncate() {
  local str="$1"
  local max="$2"
  if [[ ${#str} -gt $max ]]; then
    printf '%s' "${str:0:$max}…"
  else
    printf '%s' "$str"
  fi
}

# Get branches, pass through any arguments
branches=$(git branch "$@" 2>/dev/null | cut -c 3- | grep -v ' -> ' | grep -v 'HEAD detached at') || exit 0

if [[ -z "$branches" ]]; then
  exit 0
fi

current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

# Collect branch info with timestamps for sorting
declare -a branch_data=()

while IFS= read -r branch; do
  branch=$(echo "$branch" | xargs) # trim whitespace
  [[ -z "$branch" ]] && continue

  # Get commit info: timestamp, relative time, author, sha, message
  info=$(git log --no-walk --pretty=format:"%ct|%cr|%an|%h|%s" "$branch" -- 2>/dev/null) || continue
  [[ -z "$info" ]] && continue

  branch_data+=("$info|$branch")
done <<<"$branches"

# Sort by timestamp (first field)
sorted_data=$(printf '%s\n' "${branch_data[@]}" | sort -t'|' -k1 -n)

# Calculate max branch name length
max_branch_len=0
while IFS='|' read -r _ _ _ _ _ branch; do
  [[ ${#branch} -gt $max_branch_len ]] && max_branch_len=${#branch}
done <<<"$sorted_data"

# Output
while IFS='|' read -r timestamp timeago author sha message branch; do
  [[ -z "$branch" ]] && continue

  # Check if commit is in current HEAD
  is_present=""
  if git merge-base --is-ancestor "$sha" HEAD 2>/dev/null; then
    is_present="1"
  fi

  is_current=""
  [[ "$branch" == "$current_branch" ]] && is_current="1"

  # Determine marker
  if [[ -n "$is_current" ]]; then
    marker="→"
  elif [[ -n "$is_present" ]]; then
    marker="${GREEN}✓${RESET}"
  else
    marker=" "
  fi

  # Determine SHA color
  if [[ -n "$is_present" && -n "$is_current" ]]; then
    sha_color="$BRIGHT"
  else
    sha_color="$YELLOW"
  fi

  # Truncate fields
  timeago_trunc=$(truncate "$timeago" 20)
  author_trunc=$(truncate "$author" 20)
  message_trunc=$(truncate "$message" 60)

  # Use %b to interpret escape sequences in format string
  printf '%b%-20s%b  %b%-20s%b  %s  %b%s%b  %b%-*s%b  %b%s%b\n' \
    "$GRAY" "$timeago_trunc" "$RESET" \
    "$WHITE" "$author_trunc" "$RESET" \
    "$marker" \
    "$sha_color" "$sha" "$RESET" \
    "$GREEN" "$max_branch_len" "$branch" "$RESET" \
    "$LIGHT_GRAY" "$message_trunc" "$RESET"
done <<<"$sorted_data"
